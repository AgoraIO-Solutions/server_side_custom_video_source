diff --git a/config b/config
index 51176f3..f081300 100644
--- a/config
+++ b/config
@@ -84,6 +84,7 @@ RTMP_CORE_SRCS="                                            \
                 $ngx_addon_dir/dash/ngx_rtmp_dash_module.c  \
                 $ngx_addon_dir/hls/ngx_rtmp_mpegts.c        \
                 $ngx_addon_dir/dash/ngx_rtmp_mp4.c          \
+                $ngx_addon_dir/ngx_agora_helper.c           \
                 "
 
 
diff --git a/ngx_rtmp.h b/ngx_rtmp.h
index cbe6a93..e903dae 100644
--- a/ngx_rtmp.h
+++ b/ngx_rtmp.h
@@ -187,7 +187,7 @@ typedef struct {
 #pragma warning(disable:4200)
 #endif
 
-
+struct ngx_agora_context_t; 
 typedef struct {
     uint32_t                signature;  /* "RTMP" */ /* <-- FIXME wtf */
 
@@ -268,6 +268,9 @@ typedef struct {
     size_t                  out_queue;
     size_t                  out_cork;
     ngx_chain_t            *out[0];
+
+    struct  ngx_agora_context_t*   agora_ctx;
+
 } ngx_rtmp_session_t;
 
 
diff --git a/ngx_rtmp_cmd_module.c b/ngx_rtmp_cmd_module.c
index 13f6677..c3ec9ee 100644
--- a/ngx_rtmp_cmd_module.c
+++ b/ngx_rtmp_cmd_module.c
@@ -470,6 +470,7 @@ static ngx_int_t
 ngx_rtmp_cmd_publish_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,
         ngx_chain_t *in)
 {
+    ngx_int_t agora_rand_key=0;
     static ngx_rtmp_publish_t       v;
 
     static ngx_rtmp_amf_elt_t      in_elts[] = {
@@ -502,6 +503,11 @@ ngx_rtmp_cmd_publish_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,
 
     ngx_rtmp_cmd_fill_args(v.name, v.args);
 
+    //if the user does not provide a key, we generate random one
+    if(ngx_strlen(v.name)==0){
+        agora_rand_key=rand()%150000000;
+        ngx_sprintf(v.name, "agora-stream-key%d",agora_rand_key,10);
+    }
     ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,
                   "publish: name='%s' args='%s' type=%s silent=%d",
                   v.name, v.args, v.type, v.silent);
diff --git a/ngx_rtmp_record_module.c b/ngx_rtmp_record_module.c
index dc2de12..efbe7a4 100644
--- a/ngx_rtmp_record_module.c
+++ b/ngx_rtmp_record_module.c
@@ -1,4 +1,3 @@
-
 /*
  * Copyright (C) Roman Arutyunyan
  */
@@ -12,6 +11,7 @@
 #include "ngx_rtmp_codec_module.h"
 #include "ngx_rtmp_record_module.h"
 
+#include "ngx_agora_helper.h"
 
 ngx_rtmp_record_done_pt             ngx_rtmp_record_done;
 
@@ -446,6 +446,8 @@ ngx_rtmp_record_node_open(ngx_rtmp_session_t *s,
     rracf = rctx->conf;
     tag_size = 0;
 
+
+
     if (rctx->file.fd != NGX_INVALID_FILE) {
         return NGX_AGAIN;
     }
@@ -458,6 +460,9 @@ ngx_rtmp_record_node_open(ngx_rtmp_session_t *s,
     rctx->last = *ngx_cached_time;
     rctx->timestamp = ngx_cached_time->sec;
 
+    //TODO: we do not need to open a file
+    return NGX_OK;
+
     ngx_rtmp_record_make_path(s, rctx, &path);
 
     mode = rracf->append ? NGX_FILE_RDWR : NGX_FILE_WRONLY;
@@ -648,6 +653,16 @@ ngx_rtmp_record_start(ngx_rtmp_session_t *s)
     ngx_rtmp_record_ctx_t          *ctx;
     ngx_uint_t                      n;
 
+    #define PARAM_MAX_LEN 512
+    ngx_int_t                       bitrate=50000;
+
+    char  appid[PARAM_MAX_LEN];
+    char  channel[PARAM_MAX_LEN];
+    char  user_id[PARAM_MAX_LEN];
+    char  bitrate_str[50];
+
+    s->agora_ctx=NULL;
+
     racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_record_module);
     if (racf == NULL || racf->rec.nelts == 0) {
         return;
@@ -668,6 +683,49 @@ ngx_rtmp_record_start(ngx_rtmp_session_t *s)
         }
         ngx_rtmp_record_node_open(s, rctx);
     }
+
+    //read appid and channel id
+    memset(appid,0,PARAM_MAX_LEN);
+    memset(channel,0,PARAM_MAX_LEN);
+    memset(user_id,0,PARAM_MAX_LEN);
+    memset(bitrate_str,0,50);
+
+
+    if( parse_args(s->args,appid,channel)!=0){
+       ngx_log_error(NGX_LOG_NOTICE, s->connection->log, 0,
+                   "record: cannot find appid and/or channel in: %s",s->args.data);
+
+       return;
+    }
+
+    ngx_log_error(NGX_LOG_NOTICE, s->connection->log, 0,
+                   "record: appid=%s,channelid=%s",s->args.data,appid, channel);
+
+    //bitrate
+    if(get_arg_value(s->args,"abr",bitrate_str)==0){
+        ngx_log_error(NGX_LOG_NOTICE, s->connection->log, 0,
+                   "record: bitrate str: %s",bitrate_str);
+
+       bitrate=atoi(bitrate_str);
+    }
+
+    //user id
+    if(get_arg_value(s->args,"uid",user_id)==0){
+        ngx_log_error(NGX_LOG_NOTICE, s->connection->log, 0,
+                   "record: user id: %s",user_id);
+    }
+
+    //initialize agora
+    s->agora_ctx=ngx_agora_init(appid,channel,user_id,bitrate);
+    if(s->agora_ctx!=NULL){
+        ngx_log_error(NGX_LOG_NOTICE, s->connection->log, 0,
+                   "record: agora initialized correctly");
+    }
+    else {
+         ngx_log_error(NGX_LOG_NOTICE, s->connection->log, 0,
+                   "record: error while initializing agora");
+
+    }
 }
 
 
@@ -689,13 +747,20 @@ ngx_rtmp_record_stop(ngx_rtmp_session_t *s)
         return;
     }
 
-    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,
+    ngx_log_debug0(NGX_LOG_NOTICE, s->connection->log, 0,
                    "record: stop");
 
     rctx = ctx->rec.elts;
     for (n = 0; n < ctx->rec.nelts; ++n, ++rctx) {
         ngx_rtmp_record_node_close(s, rctx);
     }
+
+    //disconnect agora
+    ngx_agora_disconnect(&s->agora_ctx);
+
+    ngx_log_error(NGX_LOG_NOTICE, s->connection->log, 0,
+                   "record: agora has been disconected");
+
 }
 
 
@@ -794,6 +859,9 @@ ngx_rtmp_record_node_close(ngx_rtmp_session_t *s,
 
     rracf = rctx->conf;
 
+    //TODO: we do not record to a file
+    return NGX_OK;
+
     if (rctx->file.fd == NGX_INVALID_FILE) {
         return NGX_AGAIN;
     }
@@ -880,16 +948,28 @@ ngx_rtmp_record_write_frame(ngx_rtmp_session_t *s,
 
     rracf = rctx->conf;
 
-    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,
+    ngx_log_error(NGX_LOG_DEBUG, s->connection->log, 0,
                    "record: %V frame: mlen=%uD",
                    &rracf->id, h->mlen);
 
+    if(s->agora_ctx==NULL){
+
+        ngx_log_error(NGX_LOG_NOTICE, s->connection->log, 0,
+                   "record: error cannot send A/V because agora is not yet initialized");
+
+       return NGX_ERROR;
+    }
     if (h->type == NGX_RTMP_MSG_VIDEO) {
         rctx->video = 1;
+	ngx_agora_send_video(s->agora_ctx,s,h,in);
     } else {
         rctx->audio = 1;
+	ngx_agora_send_audio(s->agora_ctx,s,h,in);
     }
 
+    //we do not need to save to a file
+    return NGX_OK;
+
     timestamp = h->timestamp - rctx->epoch;
 
     if ((int32_t) timestamp < 0) {
@@ -1028,10 +1108,10 @@ ngx_rtmp_record_node_av(ngx_rtmp_session_t *s, ngx_rtmp_record_rec_ctx_t *rctx,
 
     rracf = rctx->conf;
 
-    if (rracf->flags & NGX_RTMP_RECORD_OFF) {
+   /*if (rracf->flags & NGX_RTMP_RECORD_OFF) {
         ngx_rtmp_record_node_close(s, rctx);
         return NGX_OK;
-    }
+    }*/
 
     keyframe = (h->type == NGX_RTMP_MSG_VIDEO)
              ? (ngx_rtmp_get_video_frame_type(in) == NGX_RTMP_VIDEO_KEY_FRAME)
@@ -1069,9 +1149,9 @@ ngx_rtmp_record_node_av(ngx_rtmp_session_t *s, ngx_rtmp_record_rec_ctx_t *rctx,
         return NGX_OK;
     }
 
-    if (rctx->file.fd == NGX_INVALID_FILE) {
+    /*if (rctx->file.fd == NGX_INVALID_FILE) {
         return NGX_OK;
-    }
+    }*/
 
     if (h->type == NGX_RTMP_MSG_AUDIO &&
        (rracf->flags & NGX_RTMP_RECORD_AUDIO) == 0)
